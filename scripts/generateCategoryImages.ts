import dotenv from "dotenv";
import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

dotenv.config();

// Support ESM execution (Node/ts-node) by deriving __dirname from import.meta.url
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const PEXELS_API_KEY = process.env.PEXELS_API_KEY;

if (!PEXELS_API_KEY) {
  console.error(
    "Missing PEXELS_API_KEY in environment. Please set it in your .env file."
  );
  process.exit(1);
}

interface PexelsPhotoSrc {
  original: string;
  large2x: string;
  large: string;
  medium: string;
  small: string;
  portrait: string;
  landscape: string;
  tiny: string;
}

interface PexelsPhoto {
  id: number;
  url: string;
  src: PexelsPhotoSrc;
}

interface PexelsSearchResponse {
  photos: PexelsPhoto[];
}

async function fetchCategoryImage(category: string): Promise<string | null> {
  const query = encodeURIComponent(`${category} healthy modern cooking background`);
  const url = `https://api.pexels.com/v1/search?query=${query}&per_page=1`;

  const response = await fetch(url, {
    headers: {
      Authorization: PEXELS_API_KEY as string,
    },
  });

  if (!response.ok) {
    console.warn(
      `Pexels request failed for category "${category}" with status ${response.status}`
    );
    return null;
  }

  const data = (await response.json()) as PexelsSearchResponse;
  const photo = data.photos?.[0];

  if (!photo || !photo.src) {
    console.warn(`No photo found for category "${category}"`);
    return null;
  }

  // Prefer large landscape-oriented images for backgrounds
  return photo.src.landscape || photo.src.large || photo.src.medium || null;
}

async function main() {
  // Keep this list in sync with your recipe categories and UI
  const categories = [
    "Chicken",
    "Beef",
    "Pork",
    "Fish",
    "Seafood",
    "Vegetarian",
    "Vegan",
  ];

  console.log(
    `Generating background image URLs for ${categories.length} categories using Pexels...`
  );

  const mapping: Record<string, string> = {};

  for (const category of categories) {
    console.log(`Fetching image for category: ${category}`);
    try {
      const imageUrl = await fetchCategoryImage(category);
      if (imageUrl) {
        mapping[category] = imageUrl;
      } else {
        mapping[category] = "";
      }
    } catch (error) {
      console.error(`Error fetching image for category "${category}":`, error);
      mapping[category] = "";
    }
  }

  const outputPath = path.resolve(
    __dirname,
    "../constants/category-backgrounds.generated.ts"
  );

  const fileContents = `/**
 * AUTO-GENERATED CATEGORY BACKGROUND IMAGES
 * This file was generated by scripts/generateCategoryImages.ts
 * using the Pexels API.
 */

export const CATEGORY_BACKGROUND_IMAGES: Record<string, string> = {
${Object.entries(mapping)
  .map(([key, value]) =>
    value && value.trim().length > 0
      ? `  "${key.replace(/"/g, '\\"')}": "${value.replace(/"/g, '\\"')}"`
      : `  "${key.replace(/"/g, '\\"')}": ""`
  )
  .join(",\n")}
};
`;

  fs.writeFileSync(outputPath, fileContents, { encoding: "utf8" });

  console.log(`Category background mappings written to ${outputPath}`);
  console.log(
    "You can import CATEGORY_BACKGROUND_IMAGES from this file or copy the object into your existing colors definition."
  );
}

// Execute immediately when run via ts-node / node
void main().catch((error) => {
  console.error("Error running generateCategoryImages:", error);
  process.exit(1);
});

